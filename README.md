### EN
## Introduction
The project was created based on the book *COMPILERS: PRINCIPLES, TECHNIQUES AND TOOLS* by Alfred V. Aho, Monica S. Lam, Ravi Sethi, Jeffrey D. Ullman.

The structure of a compiler is usually divided into two main parts: frontend and backend. The frontend of the compiler is responsible for analyzing the source code and is responsible for understanding its structure and meaning. It consists of phases such as:
- Lexical analysis - transforms the stream of source code characters into lexemes, which are grouped into tokens.
- Syntactic analysis - uses tokens to build a syntax tree that maps the grammatical structure of the code.
- Semantic analysis - checks whether the source code is semantically consistent and complies with the rules of the language.

In my project, I implement a frontend for a simple C-inspired language. The last two phases are integrated within the parser module. The compiler backend, which deals with generating the output code and
optimization, is not part of the project.

## Project structure
The source code is analyzed by a lexer, which generates tokens based on it. The parser transforms the stream of tokens of the source program into a syntax tree, the nodes of which are implemented as objects. These objects are responsible for constructing tree nodes, type checking, and generating intermediate code in three-address form.

The Word class supports lexemes for keywords, identifiers, and compound tokens, and operators in intermediate code. The Lexer class, whose main method is scan, recognizes numbers, identifiers, and keywords, mapping them to Word objects. The Env class assigns tokens Id objects, representing identifiers. The Type class, as a subclass of Word, transforms type names into objects.

The syntax tree nodes are implemented by the Node class, which stores the source line number in the lexline field, which makes it easier to report errors. This class supports code generation, providing methods such as gen for creating terms in three-address instructions, and reduce, which simplifies expressions to single addresses. Jumping code for logical expressions is generated by the jumping method, which redirects control to the appropriate true or false labels.

The instructions are implemented as subclasses of Stmt, which makes them easier to implement and extend. This parser structure scheme allows for efficient transformation of source code into intermediate code with support for various types and language constructs.

## Language description
A source program consists of a block containing optional declarations (*decl*) and statements (*stmt*). The **basic** token represents basic types. Productions for expressions support associativity and operator precedence. They use a hierarchy of nonterminals corresponding to individual precedence levels, ending with the nonterminal factor for parenthesized expressions, identifiers, array references, and constants.

*program* → *block*

*block* → **{** *decls stmts* **}**

*decls* → *decls decl* | *ϵ*

*decl* → *type* **id ;**

*type* → *type* **[ num ]** | **basic**

*stmts* → *stmts stmt* | *ϵ*

*stmt* → 
  *loc = bool* **;**  
  | **if** **(** *bool* **)** *stmt*  
  | **if** **(** *bool* **)** *stmt* **else** *stmt*  
  | **while** **(** *bool* **)** *stmt*  
  | **do** *stmt* **while (** *bool* **) ;**  
  | **break ;**  
  | *block*

*loc* → *loc* **[** *bool* **]** | **id**

*bool* → *bool* **||** *join* | *join*

*join* → *join* **&&** *equality* | *equality*

*equality* → 
  *equality* **==** *rel*  
  | *equality* **!=** *rel*  
  | *rel*

*rel* → 
  *expr* **<** *expr*  
  | *expr* **<=** *expr*  
  | *expr* **>=** *expr*  
  | *expr* **>** *expr*  
  | *expr*

*expr* → 
  *expr* **+** *term*  
  | *expr* **-** *term*  
  | *term*

*term* → 
  *term* **`*`** *unary*  
  | *term* **/** *unary*  
  | *unary*

*unary* → 
  **!** *unary*  
  | **-** *unary*  
  | *factor*

*factor* → 
  **(** *bool* **)**  
  | *loc*  
  | **num**  
  | **real**  
  | **true**  
  | **false**
  
### PL
Budowa kompilatora jest zazwyczaj podzielona na dwie główne części: frontend i backend. Frontend kompilatora odpowiada za analizę kodu źródłowego i jest odpowiedzialny za zrozumienie jego struktury oraz znaczenia. W jego skład wchodzą fazy takie jak:
- Analiza leksykalna – przekształca strumień znaków kodu źródłowego w leksemy, które są grupowane w tokeny.
- Analiza składniowa – używa tokenów do zbudowania drzewa składniowego, które odwzorowuje gramatyczną strukturę kodu.
- Analiza semantyczna – sprawdza, czy kod źródłowy jest spójny semantycznie i zgodny z regułami języka.

W swoim projekcie implementuję frontend dla prostego języka inspirowanego C. Dwie ostatnie fazy są zintegrowane w ramach modułu parsera. Backend kompilatora, który zajmuje się generowaniem kodu wynikowego oraz 
optymalizacją, nie jest częścią projektu.

## Struktura projektu
Kod źródłowy jest analizowany przez lekser, który na jego podstawie generuje tokeny. Parser przekształca strumień tokenów programu źródłowego w drzewo składniowe, którego węzły są implementowane jako obiekty. Te obiekty odpowiadają za konstrukcję węzłów drzewa, sprawdzanie typów i generowanie kodu pośredniego w postaci trójadresowej.

Klasa Word obsługuje leksemy dla słów kluczowych, identyfikatorów i złożonych tokenów oraz operatory w kodzie pośrednim. Klasa Lexer, której główną metodą jest scan, rozpoznaje liczby, identyfikatory i słowa kluczowe, odwzorowując je na obiekty Word. Klasa Env przypisuje tokenom obiekty Id, reprezentujące identyfikatory. Klasa Type, jako podklasa Word, przekształca nazwy typów w obiekty.

Węzły drzewa składniowego implementuje klasa Node, przechowująca w polu lexline numer wiersza kodu źródłowego, co ułatwia zgłaszanie błędów. Klasa ta wspiera generowanie kodu, dostarczając metody takie jak gen do tworzenia termów w instrukcjach trójadresowych oraz reduce, która upraszcza wyrażenia do pojedynczych adresów. Kod skaczący dla wyrażeń logicznych jest generowany metodą jumping, przekierowującą sterowanie na odpowiednie etykiety prawdy lub fałszu.

Instrukcje są realizowane jako podklasy Stmt, co ułatwia ich implementację i rozbudowę. Ten schemat struktury parsera umożliwia sprawną transformację kodu źródłowego w kod pośredni z obsługą różnych typów i konstrukcji języka.

## Opis języka
Program w języku źródłowym składa się z bloku zawierającego opjonalne deklaracje (*decl*) oraz instrukcje (*stmt*). Token **basic** reprezentuje typy podstawowe. Produkcje dla wyrażeń obsługują łączność i pierwszeństwo operatorów. Wykorzystują hierarchię nieterminali odpowiadających poszczególnym poziomom pierwszeństwa, kończącą się nieterminalem factor dla wyrażeń w nawiasach, identyfikatorów, odwołań do tablic oraz stałych.
